<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PortalTrack - Academic Progress Tracker</title>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> 
    
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="icon" type="image/png" href="portaltrack_logo.png" sizes="40x40">
    
    <style>
        /* Modernized Color Palette */
        :root {
            --primary-color: #1E88E5; /* Professional Blue */
            --secondary-color: #90A4AE; /* Soft Gray */
            --success-color: #4CAF50; /* Green */
            --danger-color: #EF5350; /* Red */
            --background-light: #F4F7F9; /* Very Light Blue-Gray Background */
            --card-background: #ffffff;
            --accent-color: #FFB300; /* Amber */
        }
        
        body { 
            font-family: 'Poppins', sans-serif; 
            margin: 0; 
            padding: 0; 
            background-color: var(--background-light); 
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            padding: 0; 
            box-sizing: border-box;
        }
        .container { 
            width: 100%;
            min-height: 100vh;
            padding: 30px; 
            background-color: var(--card-background); 
            box-shadow: none; 
            position: relative; 
            transition: margin-left 0.3s;
        }
        
        /* Adjust container margins based on sidebar state */
        .container-shifted {
            margin-left: 280px;
        }

        /* Styling for the new header structure */
        .header-content {
            display: flex;
            align-items: center;
            border-bottom: 1px solid #E0E0E0; 
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        #main-logo {
            width: 40px; 
            height: 40px;
            margin-right: 10px;
        }

        h1 { 
            color: var(--primary-color); 
            padding-bottom: 0; 
            margin: 0; 
            font-weight: 300; 
            letter-spacing: 1px;
            font-size: 2em;
        }
        h2 { color: #333; margin-top: 25px; font-weight: 500;}
        h3 { 
            color: var(--primary-color); 
            border-left: 4px solid var(--primary-color); 
            padding-left: 10px; 
            margin: 20px 0 15px; 
            font-weight: 500;
            font-size: 1.2em;
        }

        /* Form Controls */
        input[type="text"], input[type="email"], input[type="password"], input[type="number"], select, textarea {
            width: 100%; 
            padding: 12px; 
            margin: 8px 0; 
            display: inline-block; 
            border: 1px solid #CFD8DC; 
            border-radius: 8px; 
            box-sizing: border-box;
            transition: border-color 0.3s, box-shadow 0.3s;
            font-size: 1em;
            font-family: 'Poppins', sans-serif;
        }
        input:focus, textarea:focus { 
            border-color: var(--primary-color); 
            box-shadow: 0 0 0 2px rgba(30, 136, 229, 0.2); 
            outline: none; 
        }
        
        /* Buttons - Modern Flat/Shadow Style */
        button {
            background-color: var(--primary-color); 
            color: white; 
            padding: 10px 20px; 
            margin: 8px 5px 8px 0; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            font-family: 'Poppins', sans-serif;
        }
        button:hover { 
            background-color: #1976D2; 
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px); 
        }
        button.secondary { 
            background-color: var(--secondary-color);
            box-shadow: none;
            color: #333;
        }
        button.secondary:hover { background-color: #B0BEC5; color: #333; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        button.danger { background-color: var(--danger-color); }
        button.danger:hover { background-color: #E53935; }

        /* Status and Alerts */
        .error, .success { 
            padding: 12px; 
            margin-top: 15px; 
            border-radius: 8px; 
            font-weight: 500; 
            opacity: 0.95;
            transition: opacity 0.3s;
        }
        .error { background-color: #FFCDD2; color: var(--danger-color); border: 1px solid #EF9A9A; }
        .success { background-color: #C8E6C9; color: var(--success-color); border: 1px solid #A5D6A7; }
        
        /* --- VIEW MANAGEMENT --- */
        .view { 
            display: none; 
            padding: 20px 40px; 
            max-width: 100%;
        }
        .view.active { 
            display: block; 
        }

        /* --- AUTH VIEW SPECIFIC FIXES --- */
        #auth-view {
            max-width: 450px; 
            margin: 100px auto 0; 
            background: var(--card-background);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .auth-buttons-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            flex-wrap: wrap; 
        }
        .auth-buttons-left button {
            margin: 5px 10px 5px 0;
        }
        .auth-toggle {
            font-size: 0.9em;
            text-align: right;
            margin-top: 15px;
        }
        .student-login-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #E0E0E0;
        }
        /* --- END AUTH VIEW SPECIFIC FIXES --- */

        /* Sidebar Specific Styles */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 990;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .sidebar-overlay.open {
            display: block;
            opacity: 1;
        }
        .sidebar-nav {
            position: fixed;
            top: 0;
            left: -280px; 
            width: 280px;
            height: 100%;
            background-color: var(--card-background); 
            z-index: 1000;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.2);
            transition: left 0.3s ease-out;
            padding-top: 20px;
            display: flex;
            flex-direction: column;
        }
        .sidebar-nav.open {
            left: 0; 
        }
        .sidebar-header {
            padding: 10px 20px 20px;
            border-bottom: 1px solid #E0E0E0;
            margin-bottom: 10px;
        }
        .sidebar-header button {
            background: transparent;
            color: var(--secondary-color);
            box-shadow: none;
            padding: 5px;
            float: right;
            transform: none;
            font-size: 1.5em;
        }
        .sidebar-link {
            display: block;
            width: 100%;
            text-align: left;
            padding: 15px 20px;
            background: none;
            color: #333;
            border: none;
            margin: 0;
            border-radius: 0;
            transition: background-color 0.2s, color 0.2s;
            box-shadow: none;
            font-weight: 400;
        }
        .sidebar-link:hover {
            background-color: var(--background-light);
            color: var(--primary-color);
            transform: none;
        }
        .sidebar-link.danger {
            margin-top: auto; 
            border-top: 1px solid #E0E0E0;
            background-color: var(--danger-color);
            color: white;
            box-shadow: none;
        }
        .sidebar-link.danger:hover {
            background-color: #E53935;
            color: white;
        }
        .sidebar-link.nav-item-admin { 
            background-color: var(--accent-color) !important; 
            color: #333 !important;
        }

        /* Menu Toggle Button */
        #menu-toggle {
            display: none; 
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            font-size: 1.2em;
            border-radius: 0 0 8px 0; 
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1001;
            box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* General UI Elements */
        .class-item, .student-card { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            border: 1px solid #E0E0E0; 
            padding: 15px; 
            margin-bottom: 10px; 
            border-radius: 8px; 
            background-color: var(--card-background); 
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            flex-wrap: wrap; 
        }
        .student-details { flex-grow: 1; min-width: 200px; }
        .student-controls { display: flex; gap: 8px; margin-top: 5px; }
        
        /* Progress Bar for Goals */
        .progress-container {
            height: 10px;
            background-color: #E0E0E0;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
            width: 80%;
        }
        .progress-bar {
            height: 100%;
            background-color: var(--success-color);
            color: white;
            text-align: center;
            line-height: 10px;
            font-size: 8px;
            transition: width 0.5s ease;
        }
        #student-dashboard-view .progress-container {
            width: 100%;
            max-width: 500px;
        }
        
        /* Specific input styling for batch tracking */
        #student-score-input-list .weekly-score-input {
            width: 120px; 
            text-align: center; 
            font-weight: 500; 
            padding: 8px;
            margin: 0;
            flex-shrink: 0;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        /* Chat/Output Styling */
        #feedback-output, #test-output-content {
            background-color: #F5F5F5;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            line-height: 1.6;
            max-height: 300px; 
            overflow-y: auto;
            border: 1px solid #EEE;
        }
        #test-output-content .chat-message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        #test-output-content .user-message {
            background-color: #E3F2FD; 
            text-align: left; 
            border-left: 3px solid var(--primary-color);
        }
        #test-output-content .ai-message {
            background-color: #F1F8E9; 
            text-align: left;
            border-left: 3px solid var(--success-color);
            /* Important: Allow Markdown HTML to render */
            white-space: normal; 
        }
        
        /* Confirmation Modal Specifics */
        #confirm-modal .modal-content {
            max-width: 400px;
            text-align: center;
        }
        #confirm-modal-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        
        /* Loading spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 12px;
            height: 12px;
            animation: spin 2s linear infinite;
            display: inline-block;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .view {
                padding: 20px 20px; 
            }
            .container {
                padding: 0;
            }
            #auth-view {
                margin-top: 20px;
            }
        }
    </style>
</head>
<body>

    <button id="menu-toggle" onclick="toggleSidebar()" style="display: none;">‚ò∞ Menu</button>

    <div id="sidebar-overlay" class="sidebar-overlay" onclick="closeSidebar()"></div>
    <div id="sidebar-nav" class="sidebar-nav">
        <div class="sidebar-header">
            <button onclick="closeSidebar()" class="secondary">‚úñ</button>
            
            <div style="display:flex; align-items:center;">
                <img src="portaltrack_logo.png" alt="PT Logo" style="margin-right: 8px; width: 20px; height: 20px;">
                <h2 style="margin:0; color:var(--primary-color); font-weight: 500;">PortalTrack</h2>
            </div>
            
        </div>
        
        <button onclick="showView('dashboard'); closeSidebar();" id="nav-dashboard" class="sidebar-link nav-item-teacher">üè† Teacher Dashboard</button>
        <button onclick="showView('class-management'); closeSidebar();" id="nav-classes" class="sidebar-link nav-item-teacher">üìö Classes</button>
        <button onclick="showView('tracking'); closeSidebar();" id="nav-tracking" class="sidebar-link nav-item-teacher">üìù Tracking</button>
        <button onclick="openTestGeneratorModal(); closeSidebar();" id="nav-test-generator" class="sidebar-link nav-item-teacher">üß† AI Test Generator</button>
        <button onclick="showView('reports'); closeSidebar();" id="nav-reports" class="sidebar-link nav-item-teacher">üìà Reports</button>
        <button onclick="showView('admin-dashboard'); closeSidebar();" id="nav-admin-dashboard" class="sidebar-link nav-item-admin">üîë Admin Code</button>
        <button onclick="logout(); closeSidebar();" class="sidebar-link danger">üö™ Logout</button>
    </div>
    
    <div class="container">
        <div class="header-content">
            <img src="portaltrack_logo.png" alt="PortalTrack Logo" id="main-logo">
            <h1>PortalTrack</h1>
        </div>
        <div id="status-message"></div>
        
        <div id="auth-view" class="view active">
            
            <div id="login-form">
                <h2>Teacher/Admin Login</h2>
                <input type="email" id="login-email" placeholder="Email" required>
                <input type="password" id="login-password" placeholder="Password" required>
                
                <div class="auth-buttons-row">
                    <div class="auth-buttons-left">
                        <button onclick="login()">Login</button>
                        <button onclick="handlePasswordReset()" class="secondary">Forgot Password?</button>
                    </div>
                    <div class="auth-toggle">
                        New teacher? <a href="#" onclick="toggleAuthMode('register')" style="color: var(--primary-color);">Create an Account</a>
                    </div>
                </div>
            </div>

            <div id="register-form" style="display: none;">
                <h2>New Account Registration</h2>
                
                <select id="register-role" onchange="updateRegistrationForm()">
                    <option value="">--- Select Your Role ---</option>
                    <option value="teacher">Teacher</option>
                    <option value="admin">School Administrator</option>
                </select>

                <input type="email" id="register-email" placeholder="Email" required>
                <input type="password" id="register-password" placeholder="Password (min 6 chars)" required>
                
                <div id="dynamic-fields-container">
                    </div>

                <button onclick="unifiedRegister()">Register</button>
                
                <div class="auth-toggle">
                    Already have an account? <a href="#" onclick="toggleAuthMode('login')" style="color: var(--primary-color);">Login Here</a>
                </div>
            </div>

            <div class="student-login-section">
                <h2>Student Access</h2>
                <p>Enter your unique Student ID to view your progress.</p>
                <input type="text" id="student-access-id" placeholder="Enter Student ID (e.g., PT-456789)" required>
                <button onclick="studentLogin()">View My Progress</button>
            </div>
            </div>
        
        <div id="dashboard-view" class="view">
            <h2>Teacher Dashboard</h2>
            <p>Welcome! Use the **Menu button (‚ò∞)** in the top-left to navigate the application.</p>
            <h3><span style="font-size:1.5em;">üìö</span> Your Current Classes</h3>
            <div id="classes-list-dashboard">Loading classes...</div>
        </div>

        <div id="student-dashboard-view" class="view">
            <h2 id="student-dashboard-title">Student Progress for: (Loading...)</h2>
            <p>Welcome! This is your personalized, read-only academic progress dashboard.</p>
            
            <h3 style="margin-top: 30px;">üéØ My Current Goal</h3>
            <div id="student-goal-output">Loading Goal...</div>

            <h3 style="margin-top: 30px;">üìà Weekly Performance Trend</h3>
            <canvas id="student-performance-chart" style="max-height: 450px; margin-top: 20px;"></canvas>
            
            <button onclick="logout()" class="danger">üö™ Logout</button>
        </div>


        <div id="admin-dashboard-view" class="view">
            <h2>Administrator Dashboard</h2>
            <p>Welcome Admin! Use this page to manage the access code for teachers at your school.</p>
            
            <div id="admin-code-display">
                <h4>School Name: <span id="admin-school-name-output">Loading...</span></h4>
                <p>Provide this code to your teachers so they can register their accounts:</p>
                <span id="school-code-output" style="font-weight: bold; font-size: 1.2em; color: var(--primary-color);">000000</span>
                <button onclick="copySchoolCode()">Copy Code</button>
            </div>
            
            <h3 style="margin-top: 30px;">Associated Teachers</h3>
            <div id="teachers-list-admin">Loading teachers...</div>
        </div>

        <div id="class-management-view" class="view">
            <h2>Class Management</h2>
            <h3>Create New Class</h3>
            <input type="text" id="class-name" placeholder="E.g., 10th Grade Math - Term 2" required>
            <button onclick="createClass()">‚ûï Create Class</button>
            <hr>
            <h3>Manage Existing Classes</h3>
            <div id="classes-list">Loading classes...</div>
        </div>

        <div id="student-management-view" class="view">
            <h2 id="current-class-title">Manage Students for: (No Class Loaded)</h2>

            <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 300px;">
                    <h3>Add New Student (Manual)</h3>
                    <input type="text" id="student-name" placeholder="Student Full Name" required>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="addStudent()" style="flex: 1;">‚ûï Add Student</button>
                        <button onclick="openBatchImportModal()" class="secondary" style="flex: 1;">üß† AI Batch Import</button>
                    </div>
                </div>

                <div style="flex: 1; min-width: 300px;">
                    <h3>üéØ Set Student Goal (Gamification)</h3>
                    <select id="goal-student-select">
                        <option value="">Select Student</option>
                    </select>
                    <input type="number" id="target-score" placeholder="Target Weekly Score (e.g., 90)">
                    <textarea id="goal-description" placeholder="Goal description (e.g., Master Geometry Module)"></textarea>
                    <button onclick="setStudentGoal()">Set Goal</button>
                </div>
            </div>

            <hr style="margin: 20px 0;">

            <h3>Class Roster (w/ Goals & Parent Access)</h3>
            <div id="students-list">No students loaded.</div>
        </div>
        
        <div id="tracking-view" class="view">
            <h2>Fast Performance Tracking & Feedback</h2>
            
            <h3>1. Select Week to Track</h3>
            <select id="tracking-week-select-batch" onchange="loadStudentsForBatchTracking()">
                <option value="">Select Week</option>
                <option value="1">Week 1</option><option value="2">Week 2</option><option value="3">Week 3</option><option value="4">Week 4</option>
                <option value="5">Week 5</option><option value="6">Week 6</option><option value="7">Week 7</option><option value="8">Week 8</option>
                <option value="9">Week 9</option><option value="10">Week 10</option><option value="11">Week 11</option><option value="12">Week 12</option>
                <option value="13">Week 13</option><option value="14">Week 14</option><option value="15">Week 15</option><option value="16">Week 16</option>
            </select>

            <h3 style="margin-top: 25px;">2. Enter Weekly Scores (Score / 100)</h3>
            <p id="tracking-class-info" style="color: var(--secondary-color);">Please load a class in the 'Classes' tab first.</p>
            
            <div id="student-score-input-list">
                </div>
            
            <div style="margin-top: 20px;">
                <button onclick="batchRecordPerformance()" id="batch-record-button" disabled>üíæ Batch Record Scores</button>
            </div>
            
            <hr style="margin: 30px 0;">

            <h3>‚ú® AI Feedback Assistant</h3>
            <p>Generate detailed feedback for an individual student based on their complete performance history.</p>
            <select id="gemini-student-select-tracking" style="width: 70%; margin-right: 10px;">
                <option value="">Select Student</option>
            </select>
            <button onclick="generateGeminiFeedbackTracking()">Generate Feedback</button>
            <button onclick="openGeminiModal()">View Feedback History</button> 
        </div>
        <div id="reports-view" class="view">
            <h2>Reports & Analysis</h2>
            
            <h3>Individual Performance Chart</h3>
            <select id="report-student-select">
                <option value="">Select Student to View Chart</option>
            </select>
            <button onclick="displayStudentChart('performance-chart')">üìà Show Progress Chart</button>
            <canvas id="performance-chart" style="max-height: 450px; margin-top: 20px;"></canvas>

            <hr>

            <h3>Broadsheet Generation</h3>
            <p>Generates a detailed PDF summary for all students in the currently loaded class.</p>
            <button onclick="generateBroadsheet()">üìÑ Generate Broadsheet (PDF)</button>
        </div>

    </div> 
    
    <div id="edit-student-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Edit Student Information</h3>
            <input type="hidden" id="edit-student-doc-id">
            <label for="edit-student-name">Student Name</label>
            <input type="text" id="edit-student-name" required>
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button onclick="saveStudentEdit()">Save Changes</button>
                <button onclick="closeStudentEditModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <div id="batch-import-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>üß† AI Batch Student Import</h3>
            <p>Paste a list of students below (names separated by lines, commas, etc.).</p>
            
            <textarea id="batch-input-text" rows="8" placeholder="E.g.:
John Doe
Jane Smith
Mark Johnson"></textarea>
            
            <div id="batch-import-status" class="error" style="display: none; margin-top: 10px;"></div>

            <h4 style="margin-top: 20px;">Review & Import</h4>
            <div id="ai-structured-output" style="
                background-color: #f7f7f7;
                padding: 10px;
                border-radius: 8px;
                min-height: 100px;
                max-height: 250px;
                overflow-y: auto;
                border: 1px solid #eee;
                font-family: monospace;
                font-size: 0.9em;
                white-space: pre-wrap;
            ">Click 'Convert to JSON' to see AI-processed data here.</div>

            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button onclick="convertBatchToJSON()">Convert to JSON</button>
                <button onclick="importJSONStudents()" id="import-students-button" class="success" disabled>üíæ Import All Students</button>
                <button onclick="closeBatchImportModal()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>


    <div id="gemini-feedback-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>‚ú® Personalized Student Feedback</h3>
            <p>Select a student to generate AI-powered performance feedback.</p>
            <select id="gemini-student-select" style="width: 70%; margin-right: 10px;">
                <option value="">Select Student</option>
            </select>
            <button onclick="generateGeminiFeedback()">Generate</button>
            <button onclick="closeGeminiModal()" class="secondary">Close</button>
            
            <div id="feedback-status" style="margin-top: 15px;"></div>
            <pre id="feedback-output"></pre>
        </div>
    </div>

    <div id="test-generator-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>üß† AI Test Generator Chat</h3>
            <button onclick="resetTestChat()" class="secondary" style="float: right;">Start New Test</button>
            <p>Use the chat to create and refine your test or quiz content.</p>
            
            <div id="test-output-container">
                <div id="test-output-content"></div>
            </div>

            <div style="display: flex; margin-top: 15px;">
                <input type="text" id="test-chat-input" placeholder="e.g., 'Generate 5 multiple choice questions on Photosynthesis for 10th grade.'" style="flex-grow: 1; margin-right: 10px;">
                <button onclick="sendAITestMessage()">Send</button>
            </div>

            <div id="test-status" style="margin-top: 15px;"></div>
            <button onclick="closeTestGeneratorModal()" class="danger">Close</button>
        </div>
    </div>
    
    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="margin: 0; border: none; padding: 0; color: #333;">Confirmation Required</h3>
            <p id="confirm-message" style="margin-top: 15px;"></p>
            <div id="confirm-modal-buttons">
                <button id="confirm-yes" class="danger">Yes</button>
                <button id="confirm-no" class="secondary">Cancel</button>
            </div>
        </div>
    </div>


<script type="module">
    // üî• FIREBASE IMPORTS
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { 
        getAuth, 
        signInWithEmailAndPassword, 
        createUserWithEmailAndPassword, 
        signOut, 
        onAuthStateChanged, 
        sendPasswordResetEmail, 
        sendEmailVerification,
        reload,
        deleteUser 
    } 
        from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import { 
        getFirestore, 
        collection, 
        addDoc, 
        getDocs, 
        query, 
        where, 
        updateDoc, 
        deleteDoc, 
        doc,
        getDoc, 
        setDoc 
    } 
        from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

    // 1. Your Firebase Configuration 
    const firebaseConfig = {
        // !!! CRITICAL: REPLACE THIS REVOKED KEY WITH YOUR NEW, ACTIVE GEMINI API KEY !!!
        apiKey: "AIzaSyDiRSZy25IizQLRhyrSgRorw93bsN2JRKU", 
        authDomain: "portaltrack-7b46c.firebaseapp.com",
        projectId: "portaltrack-7b46c",
        storageBucket: "portaltrack-7b46c.firebasestorage.app",
        messagingSenderId: "719910046288",
        appId: "1:719910046288:web:4677f9928f4386cea51f55",
        measurementId: "G-5MGV15EHQZ"
    };

    // 2. Initialize Firebase and Services
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app); 
    const db = getFirestore(app); 

    // Global State Variables
    let currentClassId = null;
    let currentUserId = null;
    let currentSchoolId = null; 
    let currentUserRole = null; 
    let studentsData = {}; 
    let performanceChart; 
    
    // NEW STUDENT-SPECIFIC STATE
    let currentStudentDocId = null; 
    let currentStudentId = null; 
    let currentStudentName = null;
    
    let testChatHistory = [
        {
            role: "system",
            parts: [{ text: "You are an expert educational content creator named 'TestBot'. Generate and refine test and quiz content based on the user's requests. Your output must be formatted clearly using Markdown lists and headers, suitable for a printable test sheet. Always keep the entire current test or quiz in your final response, updating it based on the latest instruction. DO NOT include any introductory sentences, conversational responses, or explanations‚Äîoutput only the updated test content formatted in Markdown." }]
        },
        {
            role: "model",
            parts: [{ text: "Welcome! I'm ready to help you create a test. Start by describing the topic, grade level, and format you need (e.g., '5 multiple choice questions on the solar system for 6th grade')." }]
        }
    ];
    let parsedStudentBatch = []; 

    // Utility Functions
    const statusMessageDiv = document.getElementById('status-message');
    const showStatus = (message, isError = false) => {
        if (isError) {
            console.error(`ERROR: ${message}`);
        } else {
            console.log(`STATUS: ${message}`);
        }
        statusMessageDiv.textContent = message;
        statusMessageDiv.className = isError ? 'error' : 'success';
        setTimeout(() => statusMessageDiv.textContent = '', 5000); 
    };
    
    // Custom Confirmation Modal (Replaces window.confirm/alert)
    window.showConfirmation = (message, onConfirm) => {
        const modal = document.getElementById('confirm-modal');
        document.getElementById('confirm-message').innerHTML = message;
        
        const confirmYes = document.getElementById('confirm-yes');
        const confirmNo = document.getElementById('confirm-no');

        // Clear previous listeners
        confirmYes.onclick = null;
        confirmNo.onclick = null;

        confirmYes.onclick = () => {
            modal.style.display = 'none';
            onConfirm(true);
        };

        confirmNo.onclick = () => {
            modal.style.display = 'none';
            onConfirm(false);
        };

        modal.style.display = 'flex';
    };

    // FIX: Helper for LLM API calls 
    const callGeminiApi = async (payload) => {
        const apiKey = firebaseConfig.apiKey; 
        
        // --- CRITICAL API KEY CHECK ---
        if (apiKey.includes("YOUR_NEW_API_KEY_HERE") || apiKey.length < 30) {
            throw new Error("API Key Missing: Please ensure a valid API key is set in firebaseConfig.");
        }
        // --- END API KEY CHECK ---

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        
        let delay = 1000;
        const maxRetries = 3;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text || "Error: No text generated.";
                } else if (response.status === 429) {
                    // Rate limit exceeded, retry with backoff
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    } else {
                        throw new Error("API rate limit exceeded after multiple retries.");
                    }
                } else {
                    const errorBody = await response.json();
                    console.error("Gemini API Non-OK Response (Key/Permission Issue):", errorBody); 
                    throw new Error(errorBody.error?.message || `API call failed with status ${response.status}`);
                }
            } catch (error) {
                if (i === maxRetries - 1) {
                        throw error; // Throw the error on the last retry
                }
            }
        }
    };

    // --- Sidebar Logic ---
    window.toggleSidebar = () => {
        const sidebar = document.getElementById('sidebar-nav');
        const overlay = document.getElementById('sidebar-overlay');
        const container = document.querySelector('.container');

        if (sidebar.classList.contains('open')) {
            // Close
            sidebar.classList.remove('open');
            overlay.classList.remove('open');
            container.classList.remove('container-shifted');
        } else {
            // Open
            sidebar.classList.add('open');
            overlay.classList.add('open');
            container.classList.add('container-shifted');
        }
    }

    window.closeSidebar = () => {
        const sidebar = document.getElementById('sidebar-nav');
        const overlay = document.getElementById('sidebar-overlay');
        const container = document.querySelector('.container');
        sidebar.classList.remove('open');
        overlay.classList.remove('open');
        container.classList.remove('container-shifted');
    }
    
    const updateNavigationVisibility = () => {
        const isTeacher = currentUserRole === 'teacher';
        const isAdmin = currentUserRole === 'admin';
        const isStudent = currentStudentDocId !== null;

        // Teacher/Admin Navigation
        document.querySelectorAll('.nav-item-teacher').forEach(el => el.style.display = isTeacher ? 'block' : 'none');
        const adminNav = document.getElementById('nav-admin-dashboard');
        if (adminNav) adminNav.style.display = isAdmin ? 'block' : 'none';
        
        // Control visibility of the menu button
        const menuToggle = document.getElementById('menu-toggle');
        // Only show menu if a teacher/admin is logged in. Students don't use the sidebar.
        if (menuToggle) menuToggle.style.display = (isTeacher || isAdmin) ? 'block' : 'none';
    }

    window.showView = (viewId) => {
        // 1. Hide all views
        document.querySelectorAll('.view').forEach(view => {
            view.classList.remove('active');
            view.style.display = 'none'; 
        });
        
        // 2. Show target view
        const targetViewId = viewId === 'login' || viewId.startsWith('register') ? 'auth-view' : viewId + '-view';
        const targetView = document.getElementById(targetViewId);
        if (targetView) {
            targetView.classList.add('active');
            targetView.style.display = ''; 
        }

        if (viewId === 'class-management' || viewId === 'dashboard') {
            loadClasses();
        }
        if (viewId === 'admin-dashboard') {
            loadAdminCode();
        }
        if (viewId === 'student-management' && currentClassId) {
            loadStudents();
        }
        // MODIFIED: Only load students, actual batch list loads on week change
        if (viewId === 'tracking' && currentClassId) {
            loadStudents(true); 
        }
        if (viewId === 'student-dashboard' && currentStudentDocId) {
            loadStudentDashboard();
        }
    };
    
    window.toggleAuthMode = (mode) => {
        document.getElementById('login-form').style.display = mode === 'login' ? 'block' : 'none';
        document.getElementById('register-form').style.display = mode === 'register' ? 'block' : 'none';
        document.getElementById('student-access-id').value = ''; // Clear student ID field
        showStatus(''); 
    };

    window.updateRegistrationForm = () => {
        const role = document.getElementById('register-role').value;
        const container = document.getElementById('dynamic-fields-container');
        container.innerHTML = '';

        if (role === 'teacher') {
            container.innerHTML = `
                <input type="text" id="register-school-code" placeholder="School Code (Required by Admin)" required>
            `;
        } else if (role === 'admin') {
                container.innerHTML = `
                <input type="text" id="admin-school-name" placeholder="School Name (e.g., Central High School)" required>
            `;
        }
    };

    // ----------------------------------------------------------------------
    // 1. USER AUTHENTICATION (Teacher/Admin)
    // ----------------------------------------------------------------------

    // NEW: Helper function to retry profile read
    const readProfileWithRetry = async (db, uid, maxRetries = 3, delay = 500) => {
        const userDocRef = doc(db, "users", uid);
        for (let i = 0; i < maxRetries; i++) {
            try {
                const userDocSnap = await getDoc(userDocRef);
                if (userDocSnap.exists()) {
                    return userDocSnap;
                }
            } catch (e) {
                console.warn(`Attempt ${i + 1} to read profile failed: ${e.message}`);
            }
            if (i < maxRetries - 1) {
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2; // Exponential backoff
            }
        }
        return null; // Return null if profile not found after all retries
    };

    // NEW: Helper function to diagnose and fix missing profile document
    const diagnoseAndFixProfile = async (user) => {
        const userDocRef = doc(db, "users", user.uid);
        
        try {
            const docSnap = await getDoc(userDocRef);
            if (docSnap.exists()) {
                return docSnap;
            }

            // Document missing - attempt to repair if basic info can be found
            showStatus(`Profile document missing for ${user.email}. Attempting repair...`, true);

            // Fetch school data using the user's email domain or simply assume 'teacher' role for repair
            // NOTE: Since we don't have school ID, we have to default to minimum viable data.
            await setDoc(userDocRef, {
                userId: user.uid,
                email: user.email,
                // Assign minimal defaults (This assumes the user was meant to be a teacher 
                // and an admin exists with a default school. This is an imperfect fix 
                // but allows the user past the immediate login wall.)
                schoolId: 'DEFAULT_SCHOOL', 
                role: 'teacher', 
                createdAt: new Date(),
                repaired: true 
            });

            // Try reading immediately after repair
            const repairedSnap = await getDoc(userDocRef);
            if (repairedSnap.exists()) {
                showStatus(`Profile successfully repaired and recreated. Logging in...`, false);
                return repairedSnap;
            } else {
                throw new Error("Profile repair failed or rules denied write access.");
            }

        } catch (error) {
            console.error('Profile Diagnosis/Repair Error:', error);
            // This is the true failure point, likely due to security rules preventing the setDoc during repair
            throw new Error(`CRITICAL PROFILE ERROR: Could not read OR repair the profile document. Check your Firestore Security Rules for the '/users/{userId}' collection to ensure CREATE/WRITE access is allowed for authenticated users. Error: ${error.message}`);
        }
    }


    onAuthStateChanged(auth, async (user) => {
        if (user) {
            currentUserId = user.uid;
            
            try {
                // 1. Attempt to read profile with retry mechanism
                let userDocSnap = await readProfileWithRetry(db, user.uid);
                
                if (!userDocSnap || !userDocSnap.exists()) {
                    // 2. If retry fails, attempt to diagnose and fix
                    userDocSnap = await diagnoseAndFixProfile(user);
                }

                if (userDocSnap && userDocSnap.exists()) {
                    const userData = userDocSnap.data();
                    
                    if (!userData.role || !userData.schoolId) {
                        showStatus('User profile data incomplete. Logging out. Profile missing role or school ID.', true);
                        currentSchoolId = null;
                        currentUserRole = null;
                        await signOut(auth);
                        return;
                    }
                    
                    currentSchoolId = userData.schoolId;
                    currentUserRole = userData.role; 
                    currentStudentDocId = null; // Clear student state on teacher login
                    currentStudentId = null;
                    currentStudentName = null;
                    showStatus(`Logged in as ${currentUserRole}.`, false);

                } else {
                    // Should be caught by diagnoseAndFixProfile, but as a final fallback:
                    const userDocRef = doc(db, "users", user.uid);
                    console.error("Firestore Profile Error: Final failure to read profile for path:", userDocRef.path);
                    showStatus('Login Failed (Profile Not Found): Final verification failed. Check your Firebase Console for data integrity, or verify your Firestore Rules allow the client to READ and potentially RECREATE a missing profile in the `/users/{userId}` collection.', true);
                    currentSchoolId = null;
                    currentUserRole = null;
                    await signOut(auth);
                    return;
                }
            } catch (error) {
                // Catches errors thrown by diagnoseAndFixProfile
                showStatus(`Critical Profile Error: ${error.message}`, true);
                console.error('User Profile Load/Repair Error:', error);
                currentSchoolId = null;
                currentUserRole = null;
                await signOut(auth);
                return;
            }
            
            updateNavigationVisibility();

            if (currentUserRole === 'admin') {
                window.showView('admin-dashboard');
            } else {
                window.showView('dashboard'); 
            }
            
            if (!user.emailVerified) {
                showStatus('Welcome! Please verify your email to ensure full account access.', true);
            }
        } else if (!currentStudentDocId) {
            // Only fall back to auth-view if neither teacher/admin NOR student is logged in
            currentUserId = null;
            currentSchoolId = null;
            currentUserRole = null;
            currentStudentDocId = null;
            currentStudentId = null;
            currentStudentName = null;
            updateNavigationVisibility(); 
            closeSidebar();
            
            window.showView('login'); 
            window.toggleAuthMode('login');
        }
    });

    window.login = async () => {
        const email = document.getElementById('login-email').value;
        const password = document.getElementById('login-password').value;
        try {
            const userCredential = await signInWithEmailAndPassword(auth, email, password);
            const user = userCredential.user;

            // CRITICAL: Reload user data before checking verification status, 
            // especially after they click the verification link.
            await reload(user);
            
            if (!user.emailVerified) {
                await signOut(auth);
                showStatus('Login Blocked: Please click the verification link sent to your email. If you don\'t see it, check your spam folder.', true);
                // Resend verification email to prompt user
                await sendEmailVerification(user); 
                return;
            }

            showStatus('Login successful!', false);
        } catch (error) {
            showStatus(`Login Failed: ${error.message}`, true);
        }
    };
    
    window.logout = async () => {
        try {
            if (currentUserId) {
                await signOut(auth);
                showStatus('Teacher/Admin Logged out successfully.', false);
            } else if (currentStudentDocId) {
                // Clear student-specific state on student logout
                currentStudentDocId = null;
                currentStudentId = null;
                currentStudentName = null;
                showStatus('Student Logged out successfully.', false);
                window.showView('login');
            }
        } catch (error) {
            showStatus(`Logout Failed: ${error.message}`, true);
        }
    };
    
    // ----------------------------------------------------------------------
    // 1.B STUDENT LOGIN (ID-Only)
    // ----------------------------------------------------------------------
    
    window.studentLogin = async () => {
        const studentId = document.getElementById('student-access-id').value.trim();
        if (!studentId) {
            return showStatus('Please enter your Student ID.', true);
        }
        
        try {
            // Query the students collection using the unique Student ID
            const q = query(collection(db, "students"), where("studentId", "==", studentId));
            const snap = await getDocs(q);
            
            if (snap.empty) {
                return showStatus('Login failed: Invalid Student ID.', true);
            }
            
            // Student found - there should only be one result
            const studentDoc = snap.docs[0];
            const studentData = studentDoc.data();
            
            // Set student global state
            currentStudentDocId = studentDoc.id;
            currentStudentId = studentData.studentId;
            currentStudentName = studentData.name;
            
            // Clear teacher state
            currentUserId = null; 
            currentUserRole = null;
            
            document.getElementById('student-access-id').value = '';
            showStatus(`Welcome, ${currentStudentName}. Viewing progress dashboard.`, false);
            window.showView('student-dashboard');
            
        } catch (error) {
            // This error is likely due to the Firestore security rules.
            showStatus(`Error loading student data: ${error.message}`, true);
        }
    }
    
    // ----------------------------------------------------------------------
    // 1.C STUDENT DASHBOARD
    // ----------------------------------------------------------------------
    
    let studentChart; // Dedicated chart variable for the student view

    window.loadStudentDashboard = async () => {
        if (!currentStudentDocId) return; // Should not happen if flow is correct

        document.getElementById('student-dashboard-title').textContent = `Student Progress for: ${currentStudentName}`;
        
        // --- 1. Load Student Goal ---
        try {
            const studentRef = doc(db, "students", currentStudentDocId);
            const studentSnap = await getDoc(studentRef);
            const student = studentSnap.data();

            const goal = student.goal || { targetScore: null, description: null };
            const targetScore = goal.targetScore;
            
            document.getElementById('student-goal-output').innerHTML = '<p>Loading Performance Data...</p>'; 

            // --- 2. Load Performance Data ---
            const performanceQ = query(
                collection(db, "performanceRecords"), 
                // FIX: Use the unique studentId string (currentStudentId) 
                where("studentId", "==", currentStudentId)
            );
            const performanceSnap = await getDocs(performanceQ);

            let rawData = [];
            performanceSnap.forEach(doc => rawData.push(doc.data()));

            const scores = rawData.map(r => r.score).filter(s => s !== null && s !== undefined);
            const currentAvg = scores.length > 0 ? (scores.reduce((sum, s) => sum + s, 0) / scores.length) : 0;
            
            let goalHtml = `<div class="goal-status" style="color: var(--secondary-color);">No Goal Set by Teacher.</div>`;
            if (targetScore) {
                const progressPercent = Math.min(100, (currentAvg / targetScore) * 100).toFixed(0);
                const isComplete = currentAvg >= targetScore;
                
                goalHtml = `
                    <div class="goal-status" style="color: ${isComplete ? 'var(--success-color)' : 'var(--primary-color)'};">
                        <strong>Goal: ${goal.description || 'Target Score'}</strong>
                    </div>
                    <small>Average Score: ${currentAvg.toFixed(1)} / Target: ${targetScore}</small>
                    <div class="progress-container">
                        <div class="progress-bar" style="width: ${progressPercent}%; background-color: ${isComplete ? 'var(--success-color)' : 'var(--accent-color)'};">${progressPercent}%</div>
                    </div>
                `;
            }
            document.getElementById('student-goal-output').innerHTML = goalHtml;

            // --- 3. Render Chart ---
            const scoresMap = {};
            rawData.forEach(data => {
                scoresMap[parseInt(data.week)] = data.score || 0; 
            });

            const weeks = Object.keys(scoresMap).map(Number).sort((a, b) => a - b);
            const scoreData = weeks.map(week => scoresMap[week]);
            const weekLabels = weeks.map(w => `Week ${w}`);

            const ctx = document.getElementById('student-performance-chart').getContext('2d');

            if (studentChart) {
                studentChart.destroy();
            }

            studentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: weekLabels,
                    datasets: [{
                        label: 'My Weekly Scores',
                        data: scoreData,
                        borderColor: 'var(--primary-color)',
                        backgroundColor: 'rgba(30, 136, 229, 0.2)',
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: 'Score (%)' } },
                        x: { title: { display: true, text: 'Week Number' } }
                    },
                    plugins: { title: { display: true, text: `${currentStudentName}'s Academic Progress Trend` } }
                }
            });

        } catch (error) {
            document.getElementById('student-goal-output').innerHTML = `<p class="error">Error loading data: ${error.message}</p>`;
            console.error('Student Dashboard Load Error:', error);
        }
    }


    window.unifiedRegister = async () => {
        const role = document.getElementById('register-role').value;
        const email = document.getElementById('register-email').value;
        const password = document.getElementById('register-password').value;
        
        if (!role || password.length < 6) {
            showStatus('Please select a role and ensure password is 6+ characters.', true);
            return;
        }
        
        let schoolCode = null;
        let schoolName = null;
        let schoolDocId = null;
        let finalRole = role;
        let user = null; // Declare Auth user outside

        try {
            // --- 1. Pre-Auth Checks (Admin/Teacher) ---
            if (role === 'teacher') {
                schoolCode = document.getElementById('register-school-code').value.toUpperCase(); 
                if (!schoolCode) {
                    showStatus('School Code is mandatory for teacher registration.', true);
                    return;
                }
                
                const schoolQuery = query(collection(db, "schools"), where("code", "==", schoolCode));
                const schoolSnap = await getDocs(schoolQuery);

                if (schoolSnap.empty) {
                    showStatus(`Registration Failed: Invalid School Code (${schoolCode}).`, true);
                    return;
                }
                schoolDocId = schoolSnap.docs[0].id;
            
            } else if (role === 'admin') {
                schoolName = document.getElementById('admin-school-name').value;
                if (!schoolName) {
                    showStatus('School Name is required for administrator registration.', true);
                    return;
                }
            }
            
            // --- 2. Create Auth User ---
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            user = userCredential.user;

            // --- 3. Create Firestore Documents (Rollback protection) ---
            try {
                if (finalRole === 'admin') {
                       schoolCode = Math.random().toString(36).substring(2, 8).toUpperCase(); 
                       const schoolRef = await addDoc(collection(db, "schools"), {
                            name: schoolName,
                            code: schoolCode,
                            adminId: user.uid,
                            createdAt: new Date()
                        });
                        schoolDocId = schoolRef.id;
                }
                
                const userProfileRef = doc(db, "users", user.uid);
                await setDoc(userProfileRef, {
                    userId: user.uid,
                    email: email,
                    schoolId: schoolDocId, 
                    role: finalRole, 
                    createdAt: new Date()
                });

                // --- 4. Success Path ---
                await sendEmailVerification(user); 
                
                const successMsg = finalRole === 'admin' 
                    ? `Admin Registration successful! Your School Code for teachers is: ${schoolCode}.`
                    : 'Teacher Registration successful! A verification link has been sent to your email. **Please check your spam/junk folder if you don\'t see it.** You must click the link to log in.';

                showStatus(successMsg, false);
                
                await signOut(auth);
                window.toggleAuthMode('login');

            } catch (firestoreError) {
                // If the Firestore write fails, delete the Auth user (rollback)
                console.error('CRITICAL: Firestore Profile Write Failed. Attempting Auth User deletion.', firestoreError);
                if (user) {
                    await deleteUser(user);
                    console.log('Orphaned Auth account deleted successfully.');
                }
                showStatus(`Registration Failed (Profile Setup Error): Could not create your profile document. Please check your security rules and try again. Error: ${firestoreError.message}`, true);
                await signOut(auth); // Ensure clean state
                window.toggleAuthMode('register');
            }
            
        } catch (authError) {
            // Catches initial Auth errors (e.g., weak password, email already in use)
            showStatus(`Registration Failed (Authentication Error): ${authError.message}.`, true);
        }
    };


    
    window.handlePasswordReset = async () => {
        const email = document.getElementById('login-email').value;
        if (!email) {
            showStatus("Please enter your email in the login field first.", true);
            return;
        }
        try {
            await sendPasswordResetEmail(auth, email);
            showStatus(`Password reset email sent to ${email}.`, false);
        } catch (error) {
            showStatus(`Error sending reset email: ${error.message}`, true);
        }
    };
    
    window.loadAdminCode = async () => {
        if (currentUserRole !== 'admin' || !currentSchoolId) return;

        try {
            // --- 1. Load School Info (Code and Name) ---
            const schoolRef = doc(db, "schools", currentSchoolId);
            const schoolSnap = await getDoc(schoolRef);

            if (schoolSnap.exists()) {
                const schoolData = schoolSnap.data();
                document.getElementById('admin-school-name-output').textContent = schoolData.name;
                document.getElementById('school-code-output').textContent = schoolData.code;
            } else {
                document.getElementById('admin-school-name-output').textContent = "Error: School data missing.";
                document.getElementById('school-code-output').textContent = "N/A";
            }
            
            // --- 2. Load Associated Teachers ---
            const teachersQ = query(
                collection(db, "users"), 
                where("schoolId", "==", currentSchoolId),
                where("role", "==", "teacher")
            );
            const teachersSnap = await getDocs(teachersQ);
            
            let teachersHtml = '';
            teachersSnap.forEach((doc) => {
                const teacher = doc.data();
                teachersHtml += `
                    <div class="class-item">
                        <span>${teacher.email}</span>
                        <span style="color: #6c757d; font-size: 0.9em;">(UID: ${teacher.userId.substring(0, 6)}...)</span>
                    </div>
                `;
            });
            
            document.getElementById('teachers-list-admin').innerHTML = teachersHtml || '<p>No teachers have registered with this school code yet.</p>';

        } catch (error) {
            showStatus(`Error loading admin dashboard data: ${error.message}`, true);
        }
    };

    window.copySchoolCode = () => {
        const code = document.getElementById('school-code-output').textContent;
        if (code && code !== '000000') {
            if (navigator.clipboard) {
                navigator.clipboard.writeText(code).then(() => {
                    showStatus('School Code copied to clipboard!', false);
                }).catch(err => {
                    showStatus('Could not copy automatically. Please select and copy the code manually.', true);
                    console.error('Copy error:', err);
                });
            } else {
                 showStatus('Could not copy automatically. Please select and copy the code manually.', true);
            }
        }
    };


    // ----------------------------------------------------------------------
    // 2. CLASS MANAGEMENT (CRUD)
    // ----------------------------------------------------------------------

    window.createClass = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can create classes.', true);
        const className = document.getElementById('class-name').value;
        if (!className || !currentUserId || !currentSchoolId) {
            showStatus('Please enter a class name and ensure your school affiliation is loaded.', true);
            return;
        }
        try {
            await addDoc(collection(db, "classes"), {
                name: className,
                teacherId: currentUserId,
                schoolId: currentSchoolId, 
                createdAt: new Date()
            });
            document.getElementById('class-name').value = '';
            showStatus(`Class "${className}" created successfully.`, false);
            loadClasses();
        } catch (error) {
            showStatus(`Error creating class: ${error.message}. (Did you set up your Firestore Security Rules!)`, true);
        }
    };

    window.loadClasses = async () => {
        if (currentUserRole !== 'teacher') return;
        if (!currentUserId) return;
        
        if (!currentSchoolId) {
             document.getElementById('classes-list').innerHTML = '<p>Loading school data...</p>';
             document.getElementById('classes-list-dashboard').innerHTML = '<p>Loading school data...</p>';
             return;
        }
        
        const q = query(collection(db, "classes"), where("teacherId", "==", currentUserId));
        try {
            const querySnapshot = await getDocs(q);
            let html = '';
            querySnapshot.forEach((doc) => {
                const classData = doc.data();
                html += `
                    <div class="class-item">
                        <span><strong>${classData.name}</strong></span>
                        <div>
                            <button onclick="loadClass('${doc.id}', '${classData.name}')" class="secondary">Load Class</button>
                            <button onclick="deleteClass('${doc.id}')" class="danger">Delete</button>
                        </div>
                    </div>
                `;
            });
            document.getElementById('classes-list').innerHTML = html || '<p>No classes found. Create one above.</p>';
            document.getElementById('classes-list-dashboard').innerHTML = html || '<p>No classes found. Manage them in the Classes tab.</p>';
        } catch (error) {
            showStatus(`Error loading classes: ${error.message}. (Did you set up your Firestore Security Rules!)`, true);
        }
    };

    window.loadClass = async (classId, className) => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can manage students.', true);
        currentClassId = classId;
        document.getElementById('current-class-title').textContent = `Manage Students for: ${className}`;
        window.showView('student-management');
        loadStudents();
        showStatus(`Class "${className}" loaded.`, false);
    };

    window.deleteClass = async (classId) => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can delete classes.', true);
        
        window.showConfirmation("Are you sure you want to delete this class and ALL its associated data? This action cannot be undone.", async (confirmed) => {
            if (confirmed) {
                try {
                    await deleteDoc(doc(db, "classes", classId));
                    showStatus('Class deleted.', false);
                    loadClasses();
                    if (currentClassId === classId) currentClassId = null;
                } catch (error) {
                    showStatus(`Error deleting class: ${error.message}`, true);
                }
            }
        });
    };

    // ----------------------------------------------------------------------
    // 3. STUDENT MANAGEMENT (CRUD, Goals, Parent Token, AI Import)
    // ----------------------------------------------------------------------

    window.addStudent = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can add students.', true);
        if (!currentClassId) return showStatus('Please load a class first.', true);
        const name = document.getElementById('student-name').value;

        if (!name) {
            showStatus('Please enter student name.', true);
            return;
        }
        
        // Generate a unique, user-facing student ID
        const uniqueId = `PT-${Date.now().toString().slice(-6)}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;

        try {
            await addDoc(collection(db, "students"), {
                name: name,
                studentId: uniqueId, // Store the unique, user-facing ID
                classId: currentClassId,
                schoolId: currentSchoolId, 
                teacherId: currentUserId, 
                token: null, // Initialize token as null
                goal: { targetScore: null, description: null }, // Initialize goal
                createdAt: new Date()
            });
            document.getElementById('student-name').value = '';
            showStatus(`Student "${name}" added. ID: ${uniqueId}`, false);
            loadStudents();
        } catch (error) {
            showStatus(`Error adding student: ${error.message}`, true);
        }
    };

    window.setStudentGoal = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied.', true);
        const studentDocId = document.getElementById('goal-student-select').value;
        const targetScore = parseInt(document.getElementById('target-score').value);
        const description = document.getElementById('goal-description').value;

        if (!studentDocId || isNaN(targetScore) || !description) {
            return showStatus('Please select a student and provide a valid target score and description.', true);
        }
        if (targetScore < 1 || targetScore > 100) {
            return showStatus('Target score must be between 1 and 100.', true);
        }

        try {
            const studentRef = doc(db, "students", studentDocId);
            await updateDoc(studentRef, {
                goal: { targetScore: targetScore, description: description, setDate: new Date() }
            });
            showStatus(`Goal set for ${studentsData[studentDocId].name}.`, false);
            // Clear fields
            document.getElementById('target-score').value = '';
            document.getElementById('goal-description').value = '';
            loadStudents();
        } catch (error) {
            showStatus(`Error setting goal: ${error.message}`, true);
        }
    }

    window.generateParentToken = async (studentDocId, studentName) => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied.', true);
        
        window.showConfirmation(`Are you sure you want to generate a new read-only access token for **${studentName}**? This will replace any existing token.`, async (confirmed) => {
            if (confirmed) {
                const token = 'TR-' + crypto.randomUUID().substring(0, 10).toUpperCase().replace(/-/g, '');
                try {
                    const studentRef = doc(db, "students", studentDocId);
                    await updateDoc(studentRef, { token: token });

                    const baseUrl = window.location.origin + window.location.pathname;
                    const parentLink = `${baseUrl}?token=${token}`;

                    showStatus(`New token generated. Share this link with the parent: ${parentLink}`, false);
                    loadStudents(); // Refresh to show the new token
                } catch (error) {
                    showStatus(`Error generating token: ${error.message}`, true);
                }
            }
        });
    };

    // MODIFIED: Takes an optional parameter to indicate if we are loading for the Tracking view
    window.loadStudents = async (isTrackingView = false) => {
        if (currentUserRole !== 'teacher') return;
        if (!currentClassId) {
            document.getElementById('students-list').innerHTML = 'No class loaded.';
            return;
        }
        
        // Fetch students
        const studentsQ = query(
            collection(db, "students"), 
            where("classId", "==", currentClassId),
            where("teacherId", "==", currentUserId) 
        );

        // Fetch performance data for goal tracking
        const performanceQ = query(
            collection(db, "performanceRecords"), 
            where("classId", "==", currentClassId),
            where("teacherId", "==", currentUserId)
        );

        try {
            const [studentsSnap, performanceSnap] = await Promise.all([getDocs(studentsQ), getDocs(performanceQ)]);

            studentsData = {}; 
            const performanceMap = {};
            
            performanceSnap.forEach(d => {
                const data = d.data(); 
                // Use studentUniqueId (PT-...) as key for performance mapping
                const studentUniqueId = d.data().studentId; 
                if (!performanceMap[studentUniqueId]) {
                    performanceMap[studentUniqueId] = [];
                }
                if (data.score !== null && data.score !== undefined) {
                    performanceMap[studentUniqueId].push(data.score);
                }
            });

            let html = '';
            const studentOptions = [];
            const trackingOptions = []; // NEW: Separate array for the new tracking modal

            studentsSnap.forEach((d) => {
                const student = d.data();
                const studentDocId = d.id;
                studentsData[studentDocId] = { ...student, docId: studentDocId }; 
                
                // Populate select options
                studentOptions.push(`<option value="${studentDocId}">${student.name} (${student.studentId})</option>`);
                trackingOptions.push(`<option value="${studentDocId}">${student.name}</option>`); // Simpler name for batch tracking

                // --- Goal Tracking Logic ---
                const scores = performanceMap[student.studentId] || []; 
                const currentAvg = scores.length > 0 ? (scores.reduce((sum, s) => sum + s, 0) / scores.length) : 0;
                
                const goal = student.goal || { targetScore: null, description: null };
                const targetScore = goal.targetScore;
                
                let goalHtml = `<div class="goal-status" style="color: var(--secondary-color);">No Goal Set</div>`;
                if (targetScore) {
                    const progressPercent = Math.min(100, (currentAvg / targetScore) * 100).toFixed(0);
                    const isComplete = currentAvg >= targetScore;
                    
                    goalHtml = `
                        <div class="goal-status" style="color: ${isComplete ? 'var(--success-color)' : 'var(--primary-color)'};">
                            üéØ Current Goal: ${goal.description || 'Target Score'}
                        </div>
                        <small>Average Score: ${currentAvg.toFixed(1)} / Target: ${targetScore}</small>
                        <div class="progress-container">
                            <div class="progress-bar" style="width: ${progressPercent}%; background-color: ${isComplete ? 'var(--success-color)' : 'var(--accent-color)'};">${progressPercent}%</div>
                        </div>
                    `;
                }
                
                // --- Parent Portal Token Display ---
                const token = student.token;
                const tokenDisplay = token 
                    ? `<span style="font-family: monospace; background: #e9ecef; padding: 2px 4px; border-radius: 3px;">${token}</span>` 
                    : `<span style="color: var(--danger-color);">Inactive</span>`;
                
                
                html += `
                    <div class="student-card" id="student-${studentDocId}">
                        <div class="student-details">
                            <strong>${student.name}</strong> 
                            <small style="display: block; margin-top: 5px;">ID: ${student.studentId}</small>
                            <div style="margin-top: 10px;">${goalHtml}</div>
                            <div style="margin-top: 10px;">
                                <small>Parent Access Token: ${tokenDisplay}</small>
                            </div>
                        </div>
                        <div class="student-controls">
                            <button onclick="generateParentToken('${studentDocId}', '${student.name}')" class="secondary" title="Generate/Replace Parent Access Token">üîë Token</button>
                            <button onclick="editStudent('${studentDocId}')" class="secondary" title="Edit Student Info">‚úèÔ∏è</button>
                            <button onclick="deleteStudent('${studentDocId}')" class="danger" title="Delete Student">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            });

            // Update all student select boxes
            const studentOptionsHtml = studentOptions.join('');
            document.getElementById('report-student-select').innerHTML = '<option value="">Select Student to View Chart</option>' + studentOptionsHtml;
            document.getElementById('goal-student-select').innerHTML = '<option value="">Select Student</option>' + studentOptionsHtml;
            document.getElementById('gemini-student-select').innerHTML = '<option value="">Select Student</option>' + studentOptionsHtml;
            
            // NEW: Update the specific select box for the fast tracking view
            document.getElementById('gemini-student-select-tracking').innerHTML = '<option value="">Select Student</option>' + trackingOptions.join('');


            document.getElementById('students-list').innerHTML = html || '<p>No students found in this class.</p>';
            
            // NEW: If we are in the tracking view, automatically load the batch input interface
            if (isTrackingView) {
                loadStudentsForBatchTracking();
            }
        } catch (error) {
            showStatus(`Error loading students: ${error.message}`, true);
        }
    };

    window.deleteStudent = async (studentDocId) => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can delete students.', true);
        
        window.showConfirmation("Are you sure you want to delete this student and their performance records? This action cannot be undone.", async (confirmed) => {
            if (confirmed) {
                try {
                    // Note: In a full production environment, deleting all associated performance records 
                    // would require additional queries and writes, but for simplicity, we delete only the student doc here.
                    await deleteDoc(doc(db, "students", studentDocId));
                    showStatus('Student deleted.', false);
                    loadStudents();
                } catch (error) {
                    showStatus(`Error deleting student: ${error.message}`, true);
                }
            }
        });
    };
    
    window.editStudent = (studentDocId) => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can edit students.', true);
        const student = studentsData[studentDocId];
        if (!student) {
            showStatus('Student data not found.', true);
            return;
        }
        document.getElementById('edit-student-doc-id').value = studentDocId;
        document.getElementById('edit-student-name').value = student.name;
        document.getElementById('edit-student-modal').style.display = 'flex';
    };

    window.closeStudentEditModal = () => {
        document.getElementById('edit-student-modal').style.display = 'none';
    };

    window.saveStudentEdit = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can update student records.', true);
        const docId = document.getElementById('edit-student-doc-id').value;
        const newName = document.getElementById('edit-student-name').value;

        if (!docId || !newName) {
            showStatus('Please fill in the student name field for editing.', true);
            return;
        }

        try {
            const studentRef = doc(db, "students", docId);
            await updateDoc(studentRef, {
                name: newName,
                updatedAt: new Date()
            });
            showStatus(`Student ${newName} updated successfully.`, false);
            closeStudentEditModal();
            loadStudents(); 
        } catch (error) {
            showStatus(`Error updating student: ${error.message}`, true);
        }
    };

    // ----------------------------------------------------------------------
    // 3.B AI BATCH IMPORT FUNCTIONS
    // ----------------------------------------------------------------------

    window.openBatchImportModal = () => {
        if (!currentClassId) return showStatus('Please load a class first.', true);
        document.getElementById('batch-import-modal').style.display = 'flex';
        document.getElementById('batch-input-text').value = '';
        document.getElementById('ai-structured-output').textContent = "Click 'Convert to JSON' to see AI-processed data here.";
        document.getElementById('batch-import-status').style.display = 'none';
        document.getElementById('import-students-button').disabled = true;
        parsedStudentBatch = [];
    }

    window.closeBatchImportModal = () => {
        document.getElementById('batch-import-modal').style.display = 'none';
    }

    window.convertBatchToJSON = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied.', true);
        const inputText = document.getElementById('batch-input-text').value.trim();
        const statusDiv = document.getElementById('batch-import-status');
        const outputDiv = document.getElementById('ai-structured-output');
        const importButton = document.getElementById('import-students-button');

        if (!inputText) {
            statusDiv.textContent = 'Please paste student data to import.';
            statusDiv.className = 'error';
            statusDiv.style.display = 'block';
            outputDiv.textContent = '';
            importButton.disabled = true;
            return;
        }

        statusDiv.innerHTML = 'üß† AI processing data... <div class="loader"></div>';
        statusDiv.className = 'success';
        statusDiv.style.display = 'block';
        outputDiv.textContent = 'Processing...';
        importButton.disabled = true;

        // 1. Define the required JSON schema (ONLY NAME IS REQUIRED NOW)
        const studentSchema = {
            type: "array",
            items: {
                type: "object",
                properties: {
                    name: { type: "string", description: "The student's full name." },
                },
                required: ["name"]
            }
        };

        // 2. Construct the prompt for the AI
        const systemPrompt = "You are an expert data parsing assistant. Your task is to extract structured student names from the user's messy, unstructured text input. Your **ONLY** output must be a perfectly formed JSON array that strictly adheres to the provided schema, containing only the 'name' field. Do not add any conversational text, explanations, or markdown formatting outside of the JSON block. Ensure all names are parsed correctly.";

        const userQuery = `Extract an array of student objects from this text. Each object must only have a 'name' (string) field. \n\nTEXT TO PARSE:\n${inputText}`;

        // 3. Construct Payload with the CORRECTED field name: generationConfig
        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
            generationConfig: { 
                responseMimeType: "application/json",
                responseJsonSchema: studentSchema
            }
        };

        try {
            // 4. Call Gemini API
            const generatedText = await callGeminiApi(payload);
            
            // 5. Parse the JSON output
            const jsonMatch = generatedText.match(/```json\n([\s\S]*?)\n```/);
            const jsonString = jsonMatch ? jsonMatch[1] : generatedText; 

            parsedStudentBatch = JSON.parse(jsonString);

            if (!Array.isArray(parsedStudentBatch) || parsedStudentBatch.length === 0) {
                throw new Error("AI returned an empty or invalid array.");
            }
            
            // 6. Display and enable import
            outputDiv.textContent = JSON.stringify(parsedStudentBatch, null, 2);
            statusDiv.textContent = `‚úÖ Successfully converted ${parsedStudentBatch.length} student records. Review the data and click 'Import'.`;
            statusDiv.className = 'success';
            importButton.disabled = false;

        } catch (error) {
            console.error("AI Batch Import Error:", error);
            outputDiv.textContent = `Error: ${error.message}`;
            statusDiv.textContent = `‚ùå Failed to process data. Check the format or try again. (Details in console)`;
            statusDiv.className = 'error';
            importButton.disabled = true;
        }
    }

    window.importJSONStudents = async () => {
        if (parsedStudentBatch.length === 0) {
            return showStatus('No valid data to import.', true);
        }
        const statusDiv = document.getElementById('batch-import-status');
        const importButton = document.getElementById('import-students-button');
        importButton.disabled = true;
        
        statusDiv.innerHTML = `üöÄ Starting import of ${parsedStudentBatch.length} students... <div class="loader"></div>`;
        statusDiv.className = 'success';
        statusDiv.style.display = 'block';

        let successCount = 0;
        let failCount = 0;

        // 1. Iterate through the parsed array and perform batched Firestore writes
        const promises = parsedStudentBatch.map(student => {
            // Generate a unique, user-facing student ID for each imported student
            const uniqueId = `PT-${Date.now().toString().slice(-6)}-${Math.random().toString(36).substring(2, 6).toUpperCase()}`;

            return addDoc(collection(db, "students"), {
                name: student.name,
                studentId: uniqueId, // Now the unique, user-facing ID
                classId: currentClassId,
                schoolId: currentSchoolId,
                teacherId: currentUserId,
                token: null, 
                goal: { targetScore: null, description: null },
                createdAt: new Date()
            })
            .then(() => {
                successCount++;
            })
            .catch((error) => {
                console.error(`Failed to add ${student.name}:`, error);
                failCount++;
            });
        });

        await Promise.all(promises);

        const resultMessage = `‚úÖ Batch Import Complete! Successfully added ${successCount} students. (${failCount} failed.)`;
        showStatus(resultMessage, failCount > 0);
        
        closeBatchImportModal();
        loadStudents(); // Refresh the student roster
        parsedStudentBatch = [];
    }


    // ----------------------------------------------------------------------
    // 4. PERFORMANCE TRACKING (Gemini Integration + NEW BATCH)
    // ----------------------------------------------------------------------
    
    // NEW: Function to populate student list and existing scores for batch input
    window.loadStudentsForBatchTracking = async () => {
        if (currentUserRole !== 'teacher') return;
        const trackingListDiv = document.getElementById('student-score-input-list');
        const week = document.getElementById('tracking-week-select-batch').value;
        const classInfo = document.getElementById('tracking-class-info');
        const batchButton = document.getElementById('batch-record-button');

        if (!currentClassId) {
            classInfo.textContent = 'Please load a class in the "Classes" tab first.';
            trackingListDiv.innerHTML = '';
            batchButton.disabled = true;
            return;
        }
        
        const studentOptions = Object.values(studentsData).map(student => 
            `<option value="${student.docId}">${student.name} (${student.studentId})</option>`
        );
        document.getElementById('gemini-student-select-tracking').innerHTML = '<option value="">Select Student</option>' + studentOptions.join('');

        if (!week) {
            classInfo.textContent = `Class: ${document.getElementById('current-class-title').textContent.split(': ')[1] || 'Loaded'}. Select a Week.`;
            trackingListDiv.innerHTML = '';
            batchButton.disabled = true;
            return;
        }

        classInfo.textContent = `Class: ${document.getElementById('current-class-title').textContent.split(': ')[1] || 'Loaded'} | Tracking Week: ${week}`;
        
        // Fetch existing records for this week to pre-fill the form
        const q = query(
            collection(db, "performanceRecords"), 
            where("classId", "==", currentClassId),
            where("teacherId", "==", currentUserId),
            where("week", "==", week)
        );
        const snap = await getDocs(q);
        const existingRecords = {};
        snap.forEach(doc => {
            existingRecords[doc.data().studentId] = doc.data().score;
        });

        let html = '';
        let studentsArray = Object.values(studentsData);

        studentsArray.forEach(student => {
            const currentScore = existingRecords[student.studentId] || '';
            let scoreColor = '#CFD8DC';
            if (currentScore !== '') {
                 scoreColor = currentScore >= 90 ? 'var(--success-color)' : currentScore >= 70 ? 'var(--accent-color)' : 'var(--danger-color)';
            }
            
            html += `
                <div class="class-item" data-student-doc-id="${student.docId}" data-student-unique-id="${student.studentId}">
                    <div style="flex-grow: 1;">
                        <strong>${student.name}</strong> 
                        <small style="display: block; color: var(--secondary-color);">ID: ${student.studentId}</small>
                    </div>
                    <input type="number" 
                           min="0" max="100" 
                           placeholder="Score (0-100)" 
                           class="weekly-score-input"
                           value="${currentScore}"
                           data-student-name="${student.name}"
                           style="width: 120px; text-align: center; font-weight: 500; border: 2px solid ${scoreColor};"
                           onchange="this.style.borderColor=this.value >= 90 ? 'var(--success-color)' : this.value >= 70 ? 'var(--accent-color)' : 'var(--danger-color)';">
                </div>
            `;
        });

        trackingListDiv.innerHTML = html || '<p>No students found in this class. Add some in Class Management.</p>';
        batchButton.disabled = studentsArray.length === 0;

        if (studentsArray.length === 0) {
            batchButton.disabled = true;
        } else if (Object.keys(existingRecords).length > 0) {
            showStatus(`Pre-filled scores for Week ${week} (${Object.keys(existingRecords).length} records found).`, false);
        }
    };
    
    // NEW: Function to batch record all scores at once
    window.batchRecordPerformance = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can record performance.', true);
        if (!currentClassId) return showStatus('Please load a class first.', true);

        const week = document.getElementById('tracking-week-select-batch').value;
        if (!week) return showStatus('Please select a week first.', true);

        const inputs = document.querySelectorAll('#student-score-input-list .weekly-score-input');
        if (inputs.length === 0) return showStatus('No students to record.', true);

        window.showConfirmation(`Are you sure you want to record/update scores for **${inputs.length} students** for **Week ${week}**? Existing records for this week will likely be duplicated if not checked.`, async (confirmed) => {
            if (confirmed) {
                const batchPromises = [];
                let updatedCount = 0;
                let skippedCount = 0;

                showStatus('Batch recording in progress... Do not navigate away. <div class="loader"></div>', false);

                for (const input of inputs) {
                    const parentDiv = input.closest('.class-item');
                    const studentUniqueId = parentDiv.dataset.studentUniqueId;
                    const studentName = input.dataset.studentName;
                    const score = parseFloat(input.value);

                    if (isNaN(score) || score < 0 || score > 100) {
                        skippedCount++;
                        console.warn(`Skipping ${studentName}: Invalid score ${input.value}`);
                        continue;
                    }
                    
                    // Simple ADD DOC: For production, you'd use a batched transaction to check for existing records 
                    // (studentId + week) and UPDATE instead of CREATE. For this simple app, we create a new one.

                    batchPromises.push(addDoc(collection(db, "performanceRecords"), {
                        studentId: studentUniqueId,
                        classId: currentClassId,
                        teacherId: currentUserId,
                        week: week,
                        score: score,
                        // Nulling other non-batch fields for simplicity
                        attendance: null, 
                        midterm: null,
                        projected: null,
                        report: `Weekly score recorded via batch input for Week ${week}.`, 
                        timestamp: new Date()
                    }).then(() => {
                        updatedCount++;
                    }).catch(error => {
                        console.error(`Failed to record performance for ${studentName}:`, error);
                    }));
                }

                await Promise.all(batchPromises);
                
                showStatus(`‚úÖ Batch Complete! Successfully recorded scores for ${updatedCount} students (Skipped ${skippedCount} blank/invalid entries).`, updatedCount === 0);
                
                // Reload the list to confirm new entries
                loadStudentsForBatchTracking(); 
            }
        });
    };

    window.openGeminiModal = () => {
        document.getElementById('gemini-feedback-modal').style.display = 'flex';
        document.getElementById('feedback-output').textContent = "Select a student and click 'Generate'.";
        document.getElementById('feedback-status').textContent = '';
    }

    window.closeGeminiModal = () => {
        document.getElementById('gemini-feedback-modal').style.display = 'none';
    }
    
    // NEW: Dedicated function for the tracking view's feedback button, to avoid selecting the wrong element
    window.generateGeminiFeedbackTracking = () => {
         // Get the selected student from the *new* tracking selector
        const studentDocId = document.getElementById('gemini-student-select-tracking').value;
        // Temporarily set the main modal selector value to match
        document.getElementById('gemini-student-select').value = studentDocId;
        
        if (!studentDocId) {
             return showStatus('Please select a student from the dropdown before generating feedback.', true);
        }
        // Then call the core logic which uses the main modal selector (now correctly populated)
        openGeminiModal();
        generateGeminiFeedback();
    }


    window.generateGeminiFeedback = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can generate feedback.', true);
        const studentDocId = document.getElementById('gemini-student-select').value;
        const feedbackOutput = document.getElementById('feedback-output');
        const feedbackStatus = document.getElementById('feedback-status');

        if (!studentDocId) {
            return feedbackStatus.innerHTML = '<span class="error">Please select a student.</span>';
        }

        const student = studentsData[studentDocId];
        const studentName = student?.name || 'Student';
        const studentUniqueId = student?.studentId; // Use the unique ID for querying records

        feedbackStatus.innerHTML = 'Generating... <div class="loader"></div>';
        feedbackOutput.textContent = '';
        
        try {
            // 1. Fetch Performance Data using the UNIQUE studentId field
            const q = query(
                collection(db, "performanceRecords"), 
                where("studentId", "==", studentUniqueId), // CRITICAL: Use the student's unique ID here
                where("teacherId", "==", currentUserId) 
            );
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                feedbackStatus.innerHTML = `<span class="error">No performance records found for ${studentName}.</span>`;
                return;
            }

            let rawData = [];
            querySnapshot.forEach(doc => rawData.push(doc.data()));

            // 2. Prepare Data for LLM
            const scores = rawData.map(r => r.score).filter(s => s !== null && s !== undefined).join(', ');
            const notes = rawData.map(r => r.report).filter(r => r.trim() !== '').join('; ');
            const totalWeeks = rawData.length;
            
            const avgScore = totalWeeks > 0 
                ? (rawData.reduce((sum, r) => sum + (r.score || 0), 0) / totalWeeks).toFixed(1) 
                : 'N/A';
            
            const promptData = `
Student Name: ${studentName}
Total Weeks Tracked: ${totalWeeks}
Weekly Scores (%): [${scores}]
Average Score: ${avgScore}%
Teacher/Weekly Notes: "${notes}"
Current Goal: ${studentsData[studentDocId].goal?.description || 'None'}
`;

            // 3. Construct Payload
            const systemPrompt = "Act as a compassionate and constructive academic advisor. Your response must be a single, detailed paragraph. Analyze the provided student data (scores and notes) and summarize their performance. Offer one specific, actionable recommendation for improvement based on the data trends or notes, and one positive observation.";
            
            const userQuery = `Generate personalized feedback based on the following performance record: \n${promptData}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                tools: [{ "google_search": {} }], // Use grounding for general knowledge context
            };
            
            // 4. Call Gemini API
            const generatedText = await callGeminiApi(payload);

            // 5. Display Result
            feedbackOutput.textContent = generatedText;
            feedbackStatus.innerHTML = '<span class="success">Feedback generated successfully.</span>';

        } catch (error) {
            feedbackStatus.innerHTML = `<span class="error">Error generating feedback: ${error.message}.</span>`;
            feedbackOutput.textContent = 'Please try again later.';
        }
    };


    // ----------------------------------------------------------------------
    // 5. DATA ANALYSIS & REPORTING
    // ----------------------------------------------------------------------

    // Reusable function for rendering charts (used by both teacher and student dashboards)
    window.displayStudentChart = async (canvasId, isStudentView = false) => {
        
        let studentDocId, teacherId, chartRef;

        if (isStudentView) {
            // Student mode logic
            studentDocId = currentStudentDocId;
            teacherId = null; // Students only query their own records based on studentId field
            chartRef = studentChart;
            if (!studentDocId) return showStatus('Student data not loaded.', true);
        } else {
            // Teacher mode logic
            if (currentUserRole !== 'teacher') return showStatus('Access Denied.', true);
            studentDocId = document.getElementById('report-student-select').value;
            teacherId = currentUserId; 
            chartRef = performanceChart;
            if (!studentDocId) return showStatus('Please select a student for charting.', true);
        }
        
        const studentUniqueId = isStudentView ? currentStudentId : studentsData[studentDocId]?.studentId;
        const studentName = isStudentView ? currentStudentName : studentsData[studentDocId]?.name;
        
        const qConstraints = [where("studentId", "==", studentUniqueId)];
        if (teacherId) {
            qConstraints.push(where("teacherId", "==", teacherId));
        }

        const q = query(
            collection(db, "performanceRecords"), 
            ...qConstraints
        );

        try {
            const querySnapshot = await getDocs(q);
            
            const scoresMap = {};
            querySnapshot.forEach(doc => {
                const data = doc.data();
                scoresMap[parseInt(data.week)] = data.score || 0; 
            });

            const weeks = Object.keys(scoresMap).map(Number).sort((a, b) => a - b);
            const scores = weeks.map(week => scoresMap[week]);
            const weekLabels = weeks.map(w => `Week ${w}`);

            const ctx = document.getElementById(canvasId).getContext('2d');

            if (chartRef) {
                chartRef.destroy();
            }

            const chartData = {
                type: 'line',
                data: {
                    labels: weekLabels,
                    datasets: [{
                        label: studentName + ' Weekly Scores',
                        data: scores,
                        borderColor: 'var(--primary-color)',
                        backgroundColor: 'rgba(30, 136, 229, 0.2)',
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true, max: 100, title: { display: true, text: 'Score (%)' } },
                        x: { title: { display: true, text: 'Week Number' } }
                    },
                    plugins: { title: { display: true, text: 'Student Academic Progress Trend' } }
                }
            };

            if (isStudentView) {
                studentChart = new Chart(ctx, chartData);
            } else {
                performanceChart = new Chart(ctx, chartData);
                showStatus(`Chart displayed for ${studentName}.`, false);
            }

        } catch (error) {
            showStatus(`Error displaying chart: ${error.message}`, true);
        }
    };
    
    // Alias for teacher view
    window.displayTeacherChart = () => displayStudentChart('performance-chart', false);

    window.generateBroadsheet = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can generate reports.', true);
        if (!currentClassId) return showStatus('Please load a class before generating a broadsheet.', true);
        
        showStatus('Generating Broadsheet...', false);
        
        const { jsPDF } = window.jspdf; 
        const doc = new jsPDF();
        const classElement = document.getElementById('current-class-title');
        const className = classElement ? classElement.textContent.split(': ')[1] || 'Unknown Class' : 'Unknown Class';
        
        doc.setFontSize(16);
        doc.text(`Broadsheet Report - ${className}`, 10, 15);
        doc.setFontSize(10);
        doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 10, 20);
        
        // 1. Fetch data
        const studentsQ = query(
            collection(db, "students"), 
            where("classId", "==", currentClassId),
            where("teacherId", "==", currentUserId) 
        );
        const studentsSnap = await getDocs(studentsQ);
        
        const performanceQ = query(
            collection(db, "performanceRecords"), 
            where("classId", "==", currentClassId),
            where("teacherId", "==", currentUserId) 
        );
        const performanceSnap = await getDocs(performanceQ);
        
        // 2. Aggregate performance data by student ID (PT-...)
        const studentPerformance = {};
        performanceSnap.forEach(doc => {
            const data = doc.data();
            const studentUniqueId = data.studentId; 
            if (!studentPerformance[studentUniqueId]) {
                studentPerformance[studentUniqueId] = [];
            }
            studentPerformance[studentUniqueId].push(data);
        });

        // 3. Prepare table headers
        const headers = ["Student Name", "Student ID", "Avg Weekly Score (%)", "Latest Midterm (%)", "Weeks Tracked"];
        let rows = [];

        // 4. Fill table rows
        studentsSnap.forEach((sDoc) => {
            const student = sDoc.data();
            const studentUniqueId = student.studentId;
            const records = studentPerformance[studentUniqueId] || [];
            
            const scores = records.map(r => r.score).filter(s => s !== null && s !== undefined);
            const totalScore = scores.reduce((sum, s) => sum + s, 0);
            const avgScore = scores.length > 0 ? (totalScore / scores.length).toFixed(1) : 'N/A';
            
            const midtermScores = records.map(r => r.midterm).filter(s => s !== null && s !== undefined);
            const latestMidterm = midtermScores.length > 0 ? midtermScores[midtermScores.length - 1].toFixed(1) : 'N/A'; 

            rows.push([
                student.name,
                studentUniqueId,
                avgScore,
                latestMidterm,
                scores.length
            ]);
        });
        
        // 5. Draw table manually (FIXED ALIGNMENT)
        let startY = 30;
        const colWidths = [50, 40, 40, 40, 30]; // Adjusted for Student ID
        
        // Draw headers
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        let headerX = 10;
        headers.forEach((header, i) => {
            doc.text(header, headerX, startY);
            headerX += colWidths[i];
        });
        
        // Draw horizontal line
        doc.line(10, startY + 2, headerX - colWidths[headers.length - 1] + colWidths.reduce((a, b) => a + b) - 10, startY + 2);

        startY += 5;
        doc.setFont('helvetica', 'normal');
        
        // Draw rows
        rows.forEach(row => {
            let rowX = 10;
            startY += 7;
            
            // Handle page break
            if (startY > 280) { 
                doc.addPage();
                startY = 10;
                doc.setFont('helvetica', 'bold');
                let headerX = 10;
                headers.forEach((header, i) => {
                    doc.text(header, headerX, startY);
                    headerX += colWidths[i];
                });
                doc.line(10, startY + 2, headerX - colWidths[headers.length - 1] + colWidths.reduce((a, b) => a + b) - 10, startY + 2);
                startY += 5;
                doc.setFont('helvetica', 'normal');
            }

            row.forEach((cell, i) => {
                doc.text(String(cell), rowX, startY);
                rowX += colWidths[i];
            });
        });

        doc.save(`Broadsheet_${currentClassId}.pdf`);
        showStatus('Broadsheet generated and downloaded!', false);
    };
    
    // ----------------------------------------------------------------------
    // 6. AI TEST GENERATION (Chat Interface)
    // ----------------------------------------------------------------------

    window.renderTestChat = () => {
        const chatContainer = document.getElementById('test-output-content');
        chatContainer.innerHTML = ''; 

        // Skip the first system message
        testChatHistory.slice(1).forEach(message => {
            const role = message.role === 'user' ? 'user' : 'ai';
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${role}-message`;
            
            const rawText = message.parts[0].text;
            
            if (role === 'ai') {
                // RENDER FIX: Use marked.js to render Markdown as HTML
                messageDiv.innerHTML = marked.parse(rawText); 
            } else {
                // User messages as plain text
                messageDiv.textContent = rawText;
            }
            
            chatContainer.appendChild(messageDiv);
        });

        // Scroll to bottom
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    window.openTestGeneratorModal = () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied: Only teachers can use AI tools.', true);
        document.getElementById('test-generator-modal').style.display = 'flex';
        document.getElementById('test-status').textContent = '';
        closeSidebar();
        renderTestChat();
    }

    window.closeTestGeneratorModal = () => {
        document.getElementById('test-generator-modal').style.display = 'none';
    }

    window.resetTestChat = () => {
        testChatHistory = [
            {
                role: "system",
                parts: [{ text: "You are an expert educational content creator named 'TestBot'. Generate and refine test and quiz content based on the user's requests. Your output must be formatted clearly using Markdown lists and headers, suitable for a printable test sheet. Always keep the entire current test or quiz in your final response, updating it based on the latest instruction. DO NOT include any introductory sentences, conversational responses, or explanations‚Äîoutput only the updated test content formatted in Markdown." }]
            },
            {
                role: "model",
                parts: [{ text: "Welcome! I'm ready to help you create a test. Start by describing the topic, grade level, and format you need (e.g., '5 multiple choice questions on the solar system for 6th grade')." }]
            }
        ];
        document.getElementById('test-chat-input').value = '';
        renderTestChat();
    }
    
    window.sendAITestMessage = async () => {
        if (currentUserRole !== 'teacher') return showStatus('Access Denied.', true);
        const chatInput = document.getElementById('test-chat-input');
        const userMessage = chatInput.value.trim();
        const testStatus = document.getElementById('test-status');

        if (!userMessage) return;

        // 1. Add user message to history and render
        testChatHistory.push({ role: "user", parts: [{ text: userMessage }] });
        renderTestChat();
        chatInput.value = '';

        testStatus.innerHTML = 'Generating response... <div class="loader"></div>';

        try {
            // 2. Prepare payload
            const systemInstructionContent = testChatHistory[0].parts[0].text;

            const payload = {
                contents: testChatHistory.slice(1), // Send all messages after system instruction
                
                // FIX: Correctly structure the systemInstruction object
                systemInstruction: {
                    parts: [{ text: systemInstructionContent }] 
                },

                tools: [{ "google_search": {} }], 
            };
            
            const generatedText = await callGeminiApi(payload);

            // 3. Add AI response to history and render
            testChatHistory.push({ role: "model", parts: [{ text: generatedText }] });
            renderTestChat();
            testStatus.innerHTML = '<span class="success">Test updated successfully.</span>';

        } catch (error) {
            // 4. Handle error
            testStatus.innerHTML = `<span class="error">Error generating test: ${error.message}.</span>`;
            testChatHistory.pop(); // Remove the user message if the AI fails
            renderTestChat();
        }
    };

    // Initial setup call
    if (!currentUserId && !currentStudentDocId) {
        window.showView('login');
    }

</script>

</body>
</html>




